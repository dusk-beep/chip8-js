{
  "version": 3,
  "sources": ["../src/config.ts", "../src/constants.ts", "../src/chip8.ts", "../src/window.ts", "../src/Romdata.ts", "../src/main.ts", "../src/web.ts"],
  "sourcesContent": ["interface Config {\n  windowHeight: number;\n  windowWidth: number;\n  forgroundColor: string;\n  backgroundColor: string;\n  scaleFactor: number;\n}\n\nfunction initConfig(): Config {\n  const myConf: Config = {\n    windowWidth: 64,\n    windowHeight: 32,\n    forgroundColor: \"#33ff66\", // green #33ff66\n    backgroundColor: \"black\", // black\n    scaleFactor: 5\n  };\n  return myConf;\n}\n\nexport { initConfig, type Config };\n", "// font\n\n//prettier-ignore\nconst FONT: number[] = [\n  0xF0, 0x90, 0x90, 0x90, 0xF0, // 0\n  0x20, 0x60, 0x20, 0x20, 0x70, // 1\n  0xF0, 0x10, 0xF0, 0x80, 0xF0, // 2\n  0xF0, 0x10, 0xF0, 0x10, 0xF0, // 3\n  0x90, 0x90, 0xF0, 0x10, 0x10, // 4\n  0xF0, 0x80, 0xF0, 0x10, 0xF0, // 5\n  0xF0, 0x80, 0xF0, 0x90, 0xF0, // 6\n  0xF0, 0x10, 0x20, 0x40, 0x40, // 7\n  0xF0, 0x90, 0xF0, 0x90, 0xF0, // 8\n  0xF0, 0x90, 0xF0, 0x10, 0xF0, // 9\n  0xF0, 0x90, 0xF0, 0x90, 0x90, // A\n  0xE0, 0x90, 0xE0, 0x90, 0xE0, // B\n  0xF0, 0x80, 0x80, 0x80, 0xF0, // C\n  0xE0, 0x90, 0x90, 0x90, 0xE0, // D\n  0xF0, 0x80, 0xF0, 0x80, 0xF0, // E\n  0xF0, 0x80, 0xF0, 0x80, 0x80  // F\n]\n\nexport { FONT };\n", "import { FONT } from \"./constants.js\";\nimport { Romdata } from \"./Romdata.js\";\nimport type { Config } from \"./config.js\";\nimport type { Window } from \"./window.js\";\n\nenum Chip8State {\n  Quit,\n  Paused,\n  Running\n}\n\ninterface InstructionFormat {\n  opcode: number;\n  NNN: number;\n  NN: number;\n  N: number;\n  X: number;\n  Y: number;\n}\n\ninterface Machine {\n  ram: Uint8Array; // array of 4096 bytes\n  display: boolean[]; // 64 by 32 array where each pixel is on or off\n  stack: Uint16Array; // stack of size 12 whaere each rlment is 16 bytes\n  pc: number; // 16 bit program counter\n  delayTimer: number; // 8 bit delay timer\n  soundTimer: number; // an 8 bit sound timer\n  //keypad: boolean[]; // 16 boolean hex keys\n  //inst: InstructionFormat; // currently executing instruction\n  V: Uint8Array; // 8 bit 16 genearal purpose register\n  I: number; // index register\n  stackPtr: number; // point to top of stack\n}\n\nclass Chip8 {\n  // every oppcode is 16 bit\n  // but ram is 8 bit\n  state: Chip8State;\n  entryPoint: number = 0x200;\n  machine: Machine;\n  inst: InstructionFormat;\n  config: Config;\n  win: Window;\n  isSoundPlaying: boolean = false;\n  keypad: boolean[];\n\n  context: AudioContext;\n  oscillator: OscillatorNode | null = null;\n\n  constructor(\n    state: Chip8State = Chip8State.Running,\n    cfg: Config,\n    win: Window\n  ) {\n    this.setupInputListeners();\n    this.context = new window.AudioContext();\n    if (!this.context) {\n      throw new Error(\"no AudioContext\");\n    }\n    this.state = state;\n    this.win = win;\n    this.keypad = new Array(16).fill(false);\n    this.machine = {\n      ram: new Uint8Array(4096),\n      display: new Array(64 * 32).fill(false),\n      stack: new Uint16Array(12),\n      pc: this.entryPoint,\n      //keypad: Array(16).fill(false),\n      V: new Uint8Array(16),\n      I: 0,\n      soundTimer: 0,\n      delayTimer: 0,\n      stackPtr: -1\n    };\n    this.inst = {\n      opcode: 0,\n      NN: 0,\n      N: 0,\n      NNN: 0,\n      X: 0,\n      Y: 0\n    };\n    this.config = cfg;\n  }\n\n  draw() {\n    const {\n      windowWidth: width,\n      windowHeight: height,\n      scaleFactor,\n      forgroundColor,\n      backgroundColor\n    } = this.config;\n    const ctx = this.win.ctx!;\n\n    // Clear the canvas before drawing\n    ctx.fillStyle = backgroundColor;\n    ctx.fillRect(0, 0, width * scaleFactor, height * scaleFactor);\n\n    // Draw pixels\n    for (let i = 0; i < this.machine.display.length; i++) {\n      // Translate 1D index i value to 2D X/Y coordinates\n      // X = i % window width\n      // Y = i / window width note: should be integer\n      const x = (i % width) * scaleFactor;\n      const y = Math.floor(i / width) * scaleFactor;\n\n      // if the pixel is on then draw forground color\n      if (this.machine.display[i]) {\n        ctx.fillStyle = forgroundColor;\n        ctx.fillRect(x, y, scaleFactor, scaleFactor);\n      }\n    }\n  }\n\n  emulateTimers() {\n    if (this.machine.soundTimer > 0) {\n      this.machine.soundTimer--;\n      //this.triggerSound();\n      if (!this.isSoundPlaying) {\n        this.startSound();\n      }\n    } else {\n      // disbale sound timer\n      this.stopSound();\n    }\n\n    if (this.machine.delayTimer > 0) {\n      this.machine.delayTimer--;\n    }\n  }\n\n  startSound() {\n    if (this.oscillator === null) {\n      this.oscillator = this.context.createOscillator();\n      this.oscillator.type = \"square\";\n      this.oscillator.frequency.setValueAtTime(440, this.context.currentTime);\n      this.oscillator.connect(this.context.destination);\n      this.oscillator.start();\n    }\n  }\n\n  stopSound() {\n    if (this.oscillator !== null) {\n      this.oscillator.stop();\n      this.oscillator = null;\n    }\n  }\n\n  // load font and rom and set the initial pc to 0x200(start of rom)\n  load(romData: Romdata) {\n    // load the font on to memory (0x00 till 0x200 permitted)\n    for (let i = 0; i < FONT.length; i++) {\n      const element: number | undefined = FONT[i];\n      if (!element) continue; // ts stuff\n      this.machine.ram[i] = element;\n    }\n\n    // load the rom\n    for (let i = 0; i < romData.data.length; i++) {\n      // put the first index with the msb (big endian)\n      // eg 0x3245 => 0x0032 <-> 0x32\n      this.machine.ram[this.entryPoint + 2 * i] = romData.data[i] >> 8;\n\n      // then 0x3245 => 0x0045 <-> 0x45\n      this.machine.ram[this.entryPoint + 2 * i + 1] = romData.data[i] & 0x00ff;\n    }\n\n    // set the program counter also\n    this.machine.pc = this.entryPoint; // ie 0x200\n  }\n\n  debug() {\n    // FFFF\n    // 1NNN\n\n    this.inst.opcode = this._fetch();\n\n    // pre increment pc for the next instruction\n    //this._increment_pc();\n    //this.debug();\n\n    //fill out the current instruction format\n    this.inst.NNN = this.inst.opcode & 0x0fff; // last 12 bits\n    this.inst.NN = this.inst.opcode & 0x00ff; // last 8 bits\n    this.inst.N = this.inst.opcode & 0x000f; // only last 4 bits\n    this.inst.X = (this.inst.opcode >> 8) & 0x0f; // shift by 8 and get the last 4 bits\n    this.inst.Y = (this.inst.opcode >> 4) & 0x0f; // shift by 4 and get the last 4 bits\n\n    let msg: string = \"\";\n    // get the msb 4 bits\n    // emulate the opcode\n    switch ((this.inst.opcode >> 12) & 0x0f) {\n      case 0x00:\n        // clear the screen\n        if (this.inst.NN == 0xe0) {\n          // reset the display array to false\n          msg = \"cleared the screen\";\n        } else if (this.inst.NN == 0xee)\n          msg = `decrement stackptr return to ${this.machine.stack[this.machine.stackPtr]} `;\n\n        break;\n\n      case 0x01:\n        // Jumps to address NNN.\n        msg = `move pc from ${this.machine.pc.toString(16)} to ${this.inst.NNN.toString(16)}`;\n        break;\n\n      case 0x02:\n        // Calls subroutine at NNN.[24\n        // push the current pc to top of stack\n        // stackPtr is initailized to -1\n        //\n        msg = `incrmenet stackptr and jump to nnn ${this.machine.stackPtr} `;\n        break;\n\n      case 0x03:\n        // Skips the next instruction if VX equals NN (usually the next instruction is a jump to skip a code block)\n        msg = `skip next instruction if ${this.machine.V[this.inst.X]} == ${this.inst.NN}`;\n        break;\n\n      case 0x04:\n        // Skips the next instruction if VX equals NN (usually the next instruction is a jump to skip a code block)\n        msg = `skip next instruction if ${this.machine.V[this.inst.X]} != ${this.inst.NN}`;\n        break;\n\n      case 0x05:\n        // Skips the next instruction if VX equals VY (usually the next instruction is a jump to skip a code block)\n        msg = `skip next instruction if ${this.machine.V[this.inst.X]} == ${this.machine.V[this.inst.Y]}`;\n        break;\n\n      case 0x06:\n        // Sets VX to NN\n        msg = `sets  VX  to ${this.inst.NN.toString(16)}`;\n        break;\n\n      case 0x07:\n        // Adds NN to VX (carry flag is not changed)\n        //this.machine.V[this.inst.X] += this.inst.NN;\n        msg = `adds ${this.inst.NN} to ${this.machine.V[this.inst.X]} `;\n        break;\n      case 0x08:\n        if (this.inst.N == 0x00) {\n          // Sets VX to the value of VY.[24]\n          msg = `add Vx with Vy`;\n        } else if (this.inst.N == 0x01) {\n          // Sets VX to VX or VY. (bitwise OR operation).[24]\n          msg = `or Vx with Vy`;\n        } else if (this.inst.N == 0x02) {\n          // Sets VX to VX and VY. (bitwise AND operation).[24]\n          msg = `and Vx with Vy`;\n        } else if (this.inst.N == 0x03) {\n          //Sets VX to VX xor VY.[24]\n          msg = `xor Vx with Vy`;\n        } else if (this.inst.N == 0x04) {\n          // Adds VY to VX. VF is set to 1 when there's an overflow, and to 0 when there is not.\n          msg = `add Vx with Vy`;\n        } else if (this.inst.N == 0x05) {\n          // VY is subtracted from VX. VF is set to 0 when there's an underflow, and 1 when there is not. (i.e. VF set to 1 if VX >= VY and 0 if not).\n          msg = `sub Vx with Vy`;\n        } else if (this.inst.N == 0x06) {\n          // Shifts VX to the right by 1, then stores the least significant bit of VX prior to the shift into VF.[b][24]\n          //\n          msg = `shift Vx by 1 right`;\n        } else if (this.inst.N == 0x07) {\n          // Sets VX to VY minus VX. VF is set to 0 when there's an underflow, and 1 when there is not. (i.e. VF set to 1 if VY >= VX)\n\n          msg = \"vx = vy-vx\";\n        } else if (this.inst.N == 0x0e) {\n          // Shifts VX to the left by 1, then sets VF to 1 if the most significant bit of VX prior to that shift was set, or to 0 if it was unset.[\n          msg = `shift Vx by 1 left`;\n        }\n\n        break;\n      case 0x09:\n        // Skips the next instruction if VX not equals VY (usually the next instruction is a jump to skip a code block)\n        msg = `skip next instruction if ${this.machine.V[this.inst.X]} != ${this.machine.V[this.inst.Y]}`;\n        break;\n\n      case 0x0a:\n        // Sets I to the address NNN\n        //this.machine.I = this.inst.NNN;\n        msg = `sets I to ${this.inst.NNN}`;\n        break;\n\n      case 0x0d:\n        // Draws a sprite at coordinate (VX, VY) that has a width of 8 pixels and a height of N pixels\n        // Each row of 8 pixels is read as bit-coded starting from memory location I;\n        // I value does not change after the execution of this instruction.\n        // As described above, VF is set to 1 if any screen pixels are flipped from set to unset when the sprite is drawn, and to 0 if that does not happen.\n        msg = `draw from ${this.machine.V[this.inst.X].toString(16)},${this.machine.V[this.inst.Y].toString(16)}: ${this.inst.N.toString(16)} byte long sprite `;\n\n        break;\n\n      default:\n        // will throw in actual\n        break;\n    }\n    console.log(\n      `${this.inst.opcode.toString(16)} : ${this.machine.pc.toString(16)} :${msg} `\n    );\n  }\n\n  emulate_instruction() {\n    // FFFF\n    // 1NNN\n\n    this.inst.opcode = this._fetch();\n    // pre increment pc for the next instruction\n    this.debug();\n    this._increment_pc();\n\n    //fill out the current instruction format\n    this.inst.NNN = this.inst.opcode & 0x0fff; // last 12 bits\n    this.inst.NN = this.inst.opcode & 0x00ff; // last 8 bits\n    this.inst.N = this.inst.opcode & 0x000f; // only last 4 bits\n    this.inst.X = (this.inst.opcode >> 8) & 0x0f; // shift by 8 and get the last 4 bits\n    this.inst.Y = (this.inst.opcode >> 4) & 0x0f; // shift by 4 and get the last 4 bits\n\n    // get the msb 4 bits\n    // emulate the opcode\n    switch ((this.inst.opcode >> 12) & 0x0f) {\n      case 0x00:\n        // clear the screen\n        if (this.inst.NN == 0xe0) {\n          // reset the display array to false\n          this.machine.display = new Array(64 * 32).fill(false);\n        } else if (this.inst.NN == 0xee) {\n          this.machine.pc = this.machine.stack[this.machine.stackPtr--];\n        }\n        break;\n\n      case 0x01:\n        // Jumps to address NNN.\n        this.machine.pc = this.inst.NNN;\n        break;\n\n      case 0x02:\n        // Calls subroutine at NNN.[24\n        // push the current pc to top of stack\n        // stackPtr is initailized to -1\n        this.machine.stack[++this.machine.stackPtr] = this.machine.pc;\n        this.machine.pc = this.inst.NNN;\n\n        break;\n\n      case 0x03:\n        // Skips the next instruction if VX equals NN (usually the next instruction is a jump to skip a code block)\n        if (this.machine.V[this.inst.X] == this.inst.NN) {\n          this._increment_pc();\n        }\n        break;\n\n      case 0x04:\n        // Skips the next instruction if VX NOT equals NN (usually the next instruction is a jump to skip a code block)\n        if (this.machine.V[this.inst.X] != this.inst.NN) {\n          this._increment_pc();\n        }\n        break;\n\n      case 0x05:\n        // Skips the next instruction if VX  equals VY (usually the next instruction is a jump to skip a code block)\n        if (this.machine.V[this.inst.X] == this.machine.V[this.inst.Y]) {\n          this._increment_pc();\n        }\n        break;\n\n      case 0x06:\n        // Sets VX to NN\n        this.machine.V[this.inst.X] = this.inst.NN;\n        break;\n\n      case 0x07:\n        // Adds NN to VX (carry flag is not changed)\n        this.machine.V[this.inst.X] += this.inst.NN;\n        break;\n\n      case 0x08:\n        if (this.inst.N == 0x00) {\n          // Sets VX to the value of VY.[24]\n          this.machine.V[this.inst.X] = this.machine.V[this.inst.Y];\n        } else if (this.inst.N == 0x01) {\n          // Sets VX to VX or VY. (bitwise OR operation).[24]\n          this.machine.V[this.inst.X] |= this.machine.V[this.inst.Y];\n        } else if (this.inst.N == 0x02) {\n          // Sets VX to VX and VY. (bitwise AND operation).[24]\n          this.machine.V[this.inst.X] &= this.machine.V[this.inst.Y];\n        } else if (this.inst.N == 0x03) {\n          //Sets VX to VX xor VY.[24]\n          this.machine.V[this.inst.X] ^= this.machine.V[this.inst.Y];\n        } else if (this.inst.N == 0x04) {\n          // Adds VY to VX. VF is set to 1 when there's an overflow, and to 0 when there is not.\n          let carry = Number(\n            this.machine.V[this.inst.X] + this.machine.V[this.inst.Y] > 255\n          );\n\n          this.machine.V[this.inst.X] += this.machine.V[this.inst.Y];\n          this.machine.V[0x0f] = carry;\n        } else if (this.inst.N == 0x05) {\n          // VY is subtracted from VX. VF is set to 0 when there's an underflow, and 1 when there is not. (i.e. VF set to 1 if VX >= VY and 0 if not).\n          //\n          let underflow =\n            this.machine.V[this.inst.Y] >= this.machine.V[this.inst.X];\n\n          this.machine.V[this.inst.X] -= this.machine.V[this.inst.Y];\n          this.machine.V[0x0f] = Number(underflow);\n        } else if (this.inst.N == 0x06) {\n          // Shifts VX to the right by 1, then stores the least significant bit of VX prior to the shift into VF.[b][24]\n          this.machine.V[0x0f] = this.machine.V[this.inst.X] & 1;\n          this.machine.V[this.inst.X] >>= 1;\n        } else if (this.inst.N == 0x07) {\n          // Sets VX to VY minus VX. VF is set to 0 when there's an underflow, and 1 when there is not. (i.e. VF set to 1 if VY >= VX)\n\n          let underflow =\n            this.machine.V[this.inst.Y] >= this.machine.V[this.inst.X];\n\n          this.machine.V[this.inst.X] =\n            this.machine.V[this.inst.Y] - this.machine.V[this.inst.X];\n          this.machine.V[0x0f] = Number(underflow);\n        } else if (this.inst.N == 0x0e) {\n          // Shifts VX to the left by 1, then sets VF to 1 if the most significant bit of VX prior to that shift was set, or to 0 if it was unset.[\n          this.machine.V[0x0f] = (this.machine.V[this.inst.X] & 0x80) >> 7;\n          this.machine.V[this.inst.X] <<= 1;\n        }\n\n        break;\n\n      case 0x09:\n        // Skips the next instruction if VX NOT equals VY (usually the next instruction is a jump to skip a code block)\n        if (this.machine.V[this.inst.X] != this.machine.V[this.inst.Y]) {\n          this._increment_pc();\n        }\n        break;\n\n      case 0x0a:\n        // Sets I to the address NNN\n        this.machine.I = this.inst.NNN;\n        break;\n\n      case 0x0b:\n        // Jumps to the address NNN plus V0.[24]\n        this.machine.pc = this.machine.V[0] + this.inst.NNN;\n        break;\n\n      case 0x0c:\n        // Sets VX to the result of a bitwise and operation on a random number (Typically: 0 to 255) and NN.\n        this.machine.V[this.inst.X] =\n          Math.floor(Math.random() * 255) & this.inst.NN;\n        break;\n\n      case 0x0d:\n        // Draws a sprite at coordinate (VX, VY) that has a width of 8 pixels and a height of N pixels\n        // Each row of 8 pixels is read as bit-coded starting from memory location I;\n        // I value does not change after the execution of this instruction.\n        // As described above, VF is set to 1 if any screen pixels are flipped from set to unset when the sprite is drawn, and to 0 if that does not happen.\n\n        let xCoord = this.machine.V[this.inst.X] % this.config.windowWidth;\n        const orgX = xCoord;\n        let yCoord = this.machine.V[this.inst.Y] % this.config.windowHeight;\n        // initailize the carry flag to zero\n        this.machine.V[0x0f] = 0;\n\n        for (let i = 0; i < this.inst.N; i++) {\n          const spriteData = this.machine.ram[this.machine.I + i];\n          xCoord = orgX;\n\n          for (let j = 7; j >= 0; j--) {\n            // 1d to 2d mapping\n            // since the display is a one dimensional flattedned array\n            const pixel: boolean =\n              this.machine.display[yCoord * this.config.windowWidth + xCoord];\n\n            // 0 or 1\n            const spriteBit: number = spriteData & (1 << j) ? 1 : 0;\n\n            // pixel is on and spritebit is also on\n            // set the caryy flag to 1\n            if (pixel && spriteBit) {\n              this.machine.V[0x0f] = 1;\n            }\n\n            //this.machine.display[yCoord * this.config.windowWidth + xCoord] ^=\n            //  pixel;\n            this.machine.display[yCoord * this.config.windowWidth + xCoord] =\n              Boolean(\n                Number(\n                  this.machine.display[\n                    yCoord * this.config.windowWidth + xCoord\n                  ]\n                ) ^ (spriteBit ? 1 : 0)\n              );\n\n            if (++xCoord >= this.config.windowWidth) break;\n          }\n          if (++yCoord >= this.config.windowHeight) break;\n        }\n\n        this.draw();\n        break;\n\n      case 0x0e:\n        if (this.inst.NN == 0x9e) {\n          // Skips the next instruction if the key stored in VX(only consider the lowest nibble) is pressed (usually the next instruction is a jump to skip a code block).\n          if (this.keypad[this.machine.V[this.inst.X]]) this._increment_pc();\n        } else if (this.inst.NN == 0xa1) {\n          // Skips the next instruction if the key stored in VX(only consider the lowest nibble) is not pressed (usually the next instruction is a jump to skip a code block).\n          if (!this.keypad[this.machine.V[this.inst.X]]) this._increment_pc();\n        }\n        break;\n\n      case 0x0f:\n        switch (this.inst.NN) {\n          case 0x07:\n            // Sets VX to the value of the delay timer.[2\n            this.machine.V[this.inst.X] = this.machine.delayTimer;\n            break;\n          case 0x0a:\n            //A key press is awaited, and then stored in VX (blocking operation, all instruction halted until next key event, delay and sound timers should continue processing).\n            let keyPressed: boolean = false;\n            let key = 0xff;\n\n            for (let i = 0; i < this.keypad.length; i++) {\n              key = 0xff;\n              if (this.keypad[i]) {\n                key = i;\n                keyPressed = true;\n                break;\n              }\n            }\n\n            if (!keyPressed) {\n              this.machine.pc -= 2;\n            } else {\n              if (this.keypad[key]) this.machine.pc -= 2;\n              else {\n                this.machine.V[this.inst.X] = key;\n              }\n            }\n            break;\n          case 0x1e:\n            // Adds VX to I. VF is not affected.[c][2\n            this.machine.I += this.machine.V[this.inst.X];\n            break;\n\n          case 0x15:\n            this.machine.delayTimer = this.machine.V[this.inst.X];\n            break;\n\n          case 0x18:\n            this.machine.soundTimer = this.machine.V[this.inst.X];\n            break;\n\n          case 0x29:\n            // Sets I to the location of the sprite for the character in VX(only consider the lowest nibble). Characters 0-F (in hexadecimal) are represented by a 4x5 font.[24]\n            this.machine.I = this.machine.V[this.inst.X] * 5;\n            break;\n\n          case 0x33:\n            // Stores the binary-coded decimal representation of VX, with the hundreds digit in memory at location in I, the tens digit at location I+1, and the ones digit at location I+2\n            let bcd = this.machine.V[this.inst.X];\n\n            this.machine.ram[this.machine.I + 2] = bcd % 10;\n            bcd /= 10;\n            this.machine.ram[this.machine.I + 1] = bcd % 10;\n            bcd /= 10;\n            this.machine.ram[this.machine.I] = bcd % 10;\n            bcd /= 10;\n\n            break;\n\n          case 0x55:\n            //Stores from V0 to VX (including VX) in memory, starting at address I. The offset from I is increased by 1 for each value written, but I itself is left unmodified.[d][24]\n\n            for (let i = 0; i <= this.machine.V[this.inst.X]; i++) {\n              this.machine.ram[this.machine.I + i] = this.machine.V[i];\n            }\n            break;\n\n          case 0x65:\n            // Fills from V0 to VX (including VX) with values from memory, starting at address I. The offset from I is increased by 1 for each value read, but I itself is left unmodified.[d\n            for (let i = 0; i <= this.machine.V[this.inst.X]; i++) {\n              this.machine.V[i] = this.machine.ram[this.machine.I + i];\n            }\n            break;\n\n          default:\n            this.state = Chip8State.Quit;\n            console.log(\n              \"Setting state to Quit due to unimplemented opcode: \",\n              this.inst.opcode.toString(16)\n            );\n            throw new Error(\"unimplemented opcode\");\n        }\n        break;\n\n      default:\n        this.state = Chip8State.Quit;\n        console.log(\n          \"Setting state to Quit due to unimplemented opcode: \",\n          this.inst.opcode.toString(16)\n        );\n        throw new Error(\"unimplemented opcode\");\n    }\n  }\n\n  _increment_pc() {\n    this.machine.pc += 2;\n  }\n\n  setupInputListeners() {\n    const buttons: NodeListOf<HTMLButtonElement> =\n      document.querySelectorAll(\"button\");\n    if (buttons.length === 0) return;\n\n    const handleEvent = (\n      button: HTMLButtonElement,\n      eventType: \"keydown\" | \"keyup\",\n      event: Event\n    ) => {\n      //event.preventDefault(); // Prevent touch scrolling issues\n      this.handle_input(button, eventType);\n    };\n\n    buttons.forEach(button => {\n      //button.addEventListener(\"mousedown\", event =>\n      //  handleEvent(button, \"keydown\", event)\n      //);\n      //button.addEventListener(\"mouseup\", event =>\n      //  handleEvent(button, \"keyup\", event)\n      //);\n\n      button.addEventListener(\"touchstart\", event =>\n        handleEvent(button, \"keydown\", event)\n      );\n      button.addEventListener(\"touchend\", event =>\n        handleEvent(button, \"keyup\", event)\n      );\n      button.addEventListener(\"touchcancel\", event =>\n        handleEvent(button, \"keyup\", event)\n      ); // Handles lost touches\n    });\n  }\n\n  handle_input(button: HTMLButtonElement, eventType: \"keydown\" | \"keyup\") {\n    if (!button) return;\n\n    const keyMap: Record<string, number> = {\n      \"1\": 0x01,\n      \"2\": 0x02,\n      \"3\": 0x03,\n      \"4\": 0x0c,\n      q: 0x04,\n      w: 0x05,\n      e: 0x06,\n      r: 0x0d,\n      a: 0x07,\n      s: 0x08,\n      d: 0x09,\n      f: 0x0e,\n      z: 0x0a,\n      x: 0x00,\n      c: 0x0b,\n      v: 0x0f\n    };\n\n    const value = button.textContent?.toLowerCase(); // Ensure lowercase consistency\n    if (value) {\n      const keyCode = keyMap[value];\n\n      if (keyCode !== undefined) {\n        this.keypad[keyCode] = eventType === \"keydown\";\n      }\n    }\n  }\n\n  _fetch() {\n    if (this.machine.pc > 4094) {\n      this.state = Chip8State.Quit;\n      throw new Error(\"memory out of bounds\");\n    }\n\n    return (\n      (this.machine.ram[this.machine.pc] << 8) |\n      (this.machine.ram[this.machine.pc + 1] << 0)\n    );\n  }\n}\n\nexport { Chip8State, Chip8 };\n", "import { Chip8 } from \"./chip8.js\";\nimport type { Config } from \"./config.js\";\n\nclass Window {\n  canvas: HTMLCanvasElement | null;\n  ctx: CanvasRenderingContext2D | null;\n  width: number;\n  height: number;\n\n  constructor(conf: Config) {\n    this.canvas = document.querySelector(\".canvas\");\n    if (!this.canvas) {\n      throw Error(\"no canvas\");\n    }\n    this.canvas.width = this.width = conf.windowWidth * conf.scaleFactor;\n    this.canvas.height = this.height = conf.windowHeight * conf.scaleFactor;\n\n    //this.canvas.width = this.width = window.innerWidth;\n    //this.canvas.height = this.height = window.innerHeight;\n    this.ctx = this.canvas!.getContext(\"2d\");\n  }\n\n  clearscreen(): void {\n    this.ctx!.fillStyle = \"black\";\n    this.ctx!.fillRect(0, 0, this.width, this.height);\n  }\n}\n\nexport { Window };\n", "class Romdata {\n  data: number[];\n\n  constructor(rom: Uint8Array) {\n    this.data = [];\n\n    for (let i = 0; i < rom.length; i += 2) {\n      // convert to big endian(msb forst)\n      // eg\n      // 0x32 => 0x3200 or 0x23 => 0x3223\n      this.data.push((rom[i] << 8) | (rom[i + 1] << 0));\n    }\n  }\n\n  dump() {\n    let lines = [];\n\n    for (let i = 0; i < this.data.length; i += 8) {\n      const address = (i * 2).toString(16).padStart(6, \"0\");\n      const block = this.data.slice(i, i + 8);\n      const hexString = block\n        .map(value => value.toString(16).padStart(4, \"0\"))\n        .join(\" \");\n\n      lines.push(`${address} ${hexString}`);\n    }\n\n    return lines.join(\"\\n\");\n  }\n}\n\nexport { Romdata };\n", "import { initConfig, type Config } from \"./config.js\";\nimport { Chip8State, Chip8 } from \"./chip8.js\";\nimport { Window } from \"./window.js\";\nimport { Romdata } from \"./Romdata.js\";\n\nfunction main(arrBuf: ArrayBuffer): number {\n  const myConf: Config = initConfig();\n\n  const uint8View = new Uint8Array(arrBuf);\n  const romData = new Romdata(uint8View);\n  console.log(romData.dump()); // Debug output\n\n  const win = new Window(myConf);\n  win.clearscreen();\n\n  const chip8 = new Chip8(Chip8State.Running, myConf, win);\n  chip8.load(romData);\n\n  let timer = 0;\n  chip8.draw();\n\n  // Main emulator loop\n  function emuLoop() {\n    timer++;\n    if (chip8.state !== Chip8State.Quit) {\n      try {\n        chip8.emulate_instruction();\n      } catch (error) {\n        console.log(error);\n      }\n\n      if (timer % 5 == 0) {\n        chip8.emulateTimers();\n        timer = 0;\n      }\n      //chip8.draw();\n    }\n    setTimeout(emuLoop, 3);\n    //requestAnimationFrame(emuLoop);\n  }\n\n  // Start the emulator loop\n  emuLoop();\n  return 0;\n}\n\nexport { main };\n", "import { main } from \"./main.js\";\n\nasync function loadrom() {\n  const rom = (<HTMLSelectElement>document.getElementById(\"select\")).value;\n\n  try {\n    const resp = await fetch(`./rom/${rom}`);\n    const arrayBuffer = await resp.arrayBuffer();\n\n    if (main(arrayBuffer)) throw Error(\"unexpected error occured in main loop\");\n  } catch (error) {\n    console.log(error);\n  }\n}\n\nconsole.log(\"emtry\");\n\nconst selected = document.querySelector(\"select\");\nif (!selected) throw Error(\"no rom selected\");\nselected.addEventListener(\"change\", loadrom);\n"],
  "mappings": "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",
  "names": ["initConfig", "FONT", "Chip8", "state", "cfg", "win", "width", "height", "scaleFactor", "forgroundColor", "backgroundColor", "ctx", "i", "x", "y", "romData", "FONT", "element", "msg", "carry", "underflow", "xCoord", "orgX", "yCoord", "spriteData", "j", "pixel", "spriteBit", "keyPressed", "key", "bcd", "buttons", "handleEvent", "button", "eventType", "event", "keyMap", "value", "keyCode", "Window", "conf", "Romdata", "rom", "i", "lines", "address", "hexString", "value", "main", "arrBuf", "myConf", "initConfig", "uint8View", "romData", "Romdata", "win", "Window", "chip8", "Chip8", "timer", "emuLoop", "error", "loadrom", "rom", "arrayBuffer", "main", "error", "selected"]
}
